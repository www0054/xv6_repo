diff --git a/kernel/defs.h b/kernel/defs.h
index 59f7aae..9fc269f 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -179,6 +179,13 @@ int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
 int             test_pagetable();
+void            vmprint(pagetable_t pagetable);
+pagetable_t     kvminit2();
+void free_kernelpagetable(pagetable_t pagetable);
+pte_t *walk(pagetable_t pagetable, uint64 va, int alloc);
+uint64 kvmpa2(pagetable_t pagetable, uint64 va);
+int kvmcopymappings(pagetable_t src, pagetable_t dst, uint64 start, uint64 sz);
+uint64 kvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz);
 
 // plic.c
 void            plicinit(void);
@@ -224,3 +231,7 @@ int             sockread(struct sock *, uint64, int);
 int             sockwrite(struct sock *, uint64, int);
 void            sockrecvudp(struct mbuf*, uint32, uint16, uint16);
 #endif
+
+// vmcopyin.c
+int copyin_new(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len);
+int copyinstr_new(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max);
diff --git a/kernel/exec.c b/kernel/exec.c
index 7b8a524..526b056 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -41,6 +41,9 @@ int exec(char *path, char **argv) {
     if (ph.vaddr + ph.memsz < ph.vaddr) goto bad;
     uint64 sz1;
     if ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad;
+    if(sz1 >= PLIC) { // 防止程序大小超过 PLIC
+      goto bad;
+    }
     sz = sz1;
     if (ph.vaddr % PGSIZE != 0) goto bad;
     if (loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0) goto bad;
@@ -89,6 +92,10 @@ int exec(char *path, char **argv) {
     if (*s == '/') last = s + 1;
   safestrcpy(p->name, last, sizeof(p->name));
 
+  // 清除内核页表中对程序内存的旧映射，然后重新建立映射。
+  uvmunmap(p->k_pagetable, 0, PGROUNDUP(oldsz)/PGSIZE, 0);
+  kvmcopymappings(pagetable, p->k_pagetable, 0, sz);
+
   // Commit to the user image.
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
@@ -97,6 +104,8 @@ int exec(char *path, char **argv) {
   p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
+  if(p->pid==1) vmprint(p->pagetable);
+
   return argc;  // this ends up in a0, the first argument to main(argc, argv)
 
 bad:
diff --git a/kernel/proc.c b/kernel/proc.c
index 292ccb8..87905df 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -20,6 +20,7 @@ static void wakeup1(struct proc *chan);
 static void freeproc(struct proc *p);
 
 extern char trampoline[];  // trampoline.S
+extern char etext[];  // kernel.ld sets this to end of kernel code.
 
 // initialize the proc table at boot time.
 void procinit(void) {
@@ -28,15 +29,6 @@ void procinit(void) {
   initlock(&pid_lock, "nextpid");
   for (p = proc; p < &proc[NPROC]; p++) {
     initlock(&p->lock, "proc");
-
-    // Allocate a page for the process's kernel stack.
-    // Map it high in memory, followed by an invalid
-    // guard page.
-    char *pa = kalloc();
-    if (pa == 0) panic("kalloc");
-    uint64 va = KSTACK((int)(p - proc));
-    kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
-    p->kstack = va;
   }
   kvminithart();
 }
@@ -103,6 +95,16 @@ found:
     return 0;
   }
 
+  // Allocate a page for the process's kernel stack.
+  // Map it high in memory, followed by an invalid
+  // guard page.
+  p->k_pagetable = kvminit2();
+  char *pa = kalloc();
+  if (pa == 0) panic("kalloc");
+  uint64 va = KSTACK((int)(p - proc));
+  mappages(p->k_pagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W);
+  p->kstack = va;
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if (p->pagetable == 0) {
@@ -135,6 +137,15 @@ static void freeproc(struct proc *p) {
   p->chan = 0;
   p->killed = 0;
   p->xstate = 0;
+
+  // 释放进程的内核栈
+  void *kstack_pa = (void*)kvmpa2(p->k_pagetable, p->kstack);
+  kfree(kstack_pa);
+  p->kstack = 0;
+  // 释放进程页表
+  free_kernelpagetable(p->k_pagetable);
+  p->k_pagetable = 0;
+
   p->state = UNUSED;
 }
 
@@ -192,6 +203,7 @@ void userinit(void) {
   // and data into it.
   uvminit(p->pagetable, initcode, sizeof(initcode));
   p->sz = PGSIZE;
+  kvmcopymappings(p->pagetable, p->k_pagetable, 0, p->sz); // 同步程序内存映射到进程内核页表中
 
   // prepare for the very first "return" from kernel to user.
   p->trapframe->epc = 0;      // user program counter
@@ -213,11 +225,21 @@ int growproc(int n) {
 
   sz = p->sz;
   if (n > 0) {
-    if ((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
+    uint64 newsz;
+    if ((newsz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
       return -1;
     }
+    // 内核页表中的映射同步扩大
+    if(kvmcopymappings(p->pagetable, p->k_pagetable, sz, n) != 0) {
+      uvmdealloc(p->pagetable, newsz, sz);
+      return -1;
+    }
+    sz = newsz;
   } else if (n < 0) {
-    sz = uvmdealloc(p->pagetable, sz, sz + n);
+    // sz = uvmdealloc(p->pagetable, sz, sz + n);
+    uvmdealloc(p->pagetable, sz, sz + n);
+    // 内核页表中的映射同步缩小
+    sz = kvmdealloc(p->k_pagetable, sz, sz + n);
   }
   p->sz = sz;
   return 0;
@@ -241,6 +263,9 @@ int fork(void) {
     release(&np->lock);
     return -1;
   }
+  // 调用 kvmcopymappings，将新进程用户页表映射拷贝一份到新进程内核页表中
+  kvmcopymappings(np->pagetable, np->k_pagetable, 0, p->sz);
+
   np->sz = p->sz;
 
   np->parent = p;
@@ -430,7 +455,11 @@ void scheduler(void) {
         // before jumping back to us.
         p->state = RUNNING;
         c->proc = p;
+
+        w_satp(MAKE_SATP(p->k_pagetable));
+        sfence_vma();
         swtch(&c->context, &p->context);
+        kvminithart();
 
         // Process is done running for now.
         // It should have changed its p->state before coming back.
diff --git a/kernel/proc.h b/kernel/proc.h
index 9c16ea7..b859fc9 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -103,4 +103,5 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  pagetable_t k_pagetable;     // Kernel page table
 };
diff --git a/kernel/vm.c b/kernel/vm.c
index b794885..77f0e15 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,6 +5,8 @@
 #include "riscv.h"
 #include "defs.h"
 #include "fs.h"
+#include "spinlock.h"
+#include "proc.h"
 
 /*
  * the kernel's page table.
@@ -15,34 +17,14 @@ extern char etext[];  // kernel.ld sets this to end of kernel code.
 
 extern char trampoline[];  // trampoline.S
 
+
+
 /*
  * create a direct-map page table for the kernel.
  */
 void kvminit() {
-  kernel_pagetable = (pagetable_t)kalloc();
-  memset(kernel_pagetable, 0, PGSIZE);
-
-  // uart registers
-  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);
-
-  // virtio mmio disk interface
-  kvmmap(VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
-
-  // CLINT
-  kvmmap(CLINT, CLINT, 0x10000, PTE_R | PTE_W);
-
-  // PLIC
-  kvmmap(PLIC, PLIC, 0x400000, PTE_R | PTE_W);
-
-  // map kernel text executable and read-only.
-  kvmmap(KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
-
-  // map kernel data and the physical RAM we'll make use of.
-  kvmmap((uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
-
-  // map the trampoline for trap entry/exit to
-  // the highest virtual address in the kernel.
-  kvmmap(TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+  kernel_pagetable = kvminit2();
+  mappages(kernel_pagetable, CLINT, 0x10000, CLINT, PTE_R | PTE_W);
 }
 
 // Switch h/w page table register to the kernel's page table,
@@ -113,7 +95,7 @@ uint64 kvmpa(uint64 va) {
   pte_t *pte;
   uint64 pa;
 
-  pte = walk(kernel_pagetable, va, 0);
+  pte = walk(myproc()->k_pagetable, va, 0);
   if (pte == 0) panic("kvmpa");
   if ((*pte & PTE_V) == 0) panic("kvmpa");
   pa = PTE2PA(*pte);
@@ -316,21 +298,7 @@ int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
 // Copy len bytes to dst from virtual address srcva in a given page table.
 // Return 0 on success, -1 on error.
 int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
-  uint64 n, va0, pa0;
-
-  while (len > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > len) n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
-
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
+  return copyin_new(pagetable, dst, srcva, len);
 }
 
 // Copy a null-terminated string from user to kernel.
@@ -338,44 +306,159 @@ int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len) {
 // until a '\0', or max.
 // Return 0 on success, -1 on error.
 int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max) {
-  uint64 n, va0, pa0;
-  int got_null = 0;
+  return copyinstr_new(pagetable, dst, srcva, max);
+}
 
-  while (got_null == 0 && max > 0) {
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if (pa0 == 0) return -1;
-    n = PGSIZE - (srcva - va0);
-    if (n > max) n = max;
-
-    char *p = (char *)(pa0 + (srcva - va0));
-    while (n > 0) {
-      if (*p == '\0') {
-        *dst = '\0';
-        got_null = 1;
+// check if use global kpgtbl or not
+int test_pagetable() {
+  uint64 satp = r_satp();
+  uint64 gsatp = MAKE_SATP(kernel_pagetable);
+  printf("test_pagetable: %d\n", satp != gsatp);
+  return satp != gsatp;
+}
+
+
+void fmtprint(pagetable_t pagetable, int level){
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if(pte & PTE_V){
+      uint64 pa = PTE2PA(pte);
+      uint64 va;
+      switch (level)
+      {
+      case 2:
+        printf("||idx: %d: pa: %p, flags: ",i,pa);
+        printf("%s",((pte&PTE_R) == 0?"-":"r"));
+        printf("%s",((pte&PTE_W) == 0?"-":"w"));
+        printf("%s",((pte&PTE_X) == 0?"-":"x"));
+        printf("%s\n",((pte&PTE_U) == 0?"-":"u"));
+        fmtprint((pagetable_t)pa,level-1);
         break;
-      } else {
-        *dst = *p;
+      case 1:
+        printf("||   ||idx: %d: pa: %p, flags: ",i,pa);
+        printf("%s",((pte&PTE_R) == 0?"-":"r"));
+        printf("%s",((pte&PTE_W) == 0?"-":"w"));
+        printf("%s",((pte&PTE_X) == 0?"-":"x"));
+        printf("%s\n",((pte&PTE_U) == 0?"-":"u"));
+        fmtprint((pagetable_t)pa,level-1);
+        break;
+      case 0:
+        for(uint64 j = 0x0;;j++){
+          if(PX(level, (uint64)j) == i){
+            va = j;
+            break;
+          }
+        }
+        printf("||   ||   ||idx: %d: va: %p -> pa: %p, flags: ",i, va, pa);
+        printf("%s",((pte&PTE_R) == 0?"-":"r"));
+        printf("%s",((pte&PTE_W) == 0?"-":"w"));
+        printf("%s",((pte&PTE_X) == 0?"-":"x"));
+        printf("%s\n",((pte&PTE_U) == 0?"-":"u"));
       }
-      --n;
-      --max;
-      p++;
-      dst++;
     }
+  }
+}
+
+void vmprint(pagetable_t pagetable){
+  printf("page table %p\n",pagetable);
+  fmtprint(pagetable,2);
+}
+
+// 创建内核页表
+pagetable_t kvminit2(){
+  pagetable_t kernel_pagetable = (pagetable_t) kalloc();
+  memset(kernel_pagetable, 0, PGSIZE);
+
+  // uart registers
+  mappages(kernel_pagetable, UART0, PGSIZE, UART0, PTE_R | PTE_W);
+  
+  // virtio mmio disk interface
+  mappages(kernel_pagetable, VIRTIO0, PGSIZE, VIRTIO0, PTE_R | PTE_W);
+
+  // PLIC
+  mappages(kernel_pagetable, PLIC, 0x400000, PLIC, PTE_R | PTE_W);
+
+  // map kernel text executable and read-only.
+  mappages(kernel_pagetable, KERNBASE, (uint64)etext-KERNBASE, KERNBASE, PTE_R | PTE_X);
+
+  // map kernel data and the physical RAM we'll make use of.
+  mappages(kernel_pagetable, (uint64)etext, PHYSTOP-(uint64)etext, (uint64)etext, PTE_R | PTE_W);
+
+  // map the trampoline for trap entry/exit to
+  // the highest virtual address in the kernel.
+  mappages(kernel_pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X);
+  return kernel_pagetable;
+}
+
+// translate a kernel virtual address to
+// a physical address.
+// 在kvmpa加一个pagetable的参数
+uint64 kvmpa2(pagetable_t pagetable, uint64 va) {
+  uint64 off = va % PGSIZE;
+  pte_t *pte;
+  uint64 pa;
+
+  pte = walk(pagetable, va, 0);
+  if (pte == 0) panic("kvmpa");
+  if ((*pte & PTE_V) == 0) panic("kvmpa");
+  pa = PTE2PA(*pte);
+  return pa + off;
+}
+
+// 递归释放整个多级页表树
+void free_kernelpagetable(pagetable_t pagetable){
+  // there are 2^9 = 512 PTEs in a page table.
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0){
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte);
+      free_kernelpagetable((pagetable_t)child);
+      pagetable[i] = 0;
+    }
+  }
+  kfree((void *)pagetable);
+}
 
-    srcva = va0 + PGSIZE;
+// 将 old 页表的一部分页映射关系拷贝到 new 页表中
+// uvmcopy类似,只拷贝页表项，不拷贝实际的物理页内存
+int kvmcopymappings(pagetable_t old, pagetable_t new, uint64 start, uint64 sz)
+{
+  pte_t *pte;
+  uint64 pa, i;
+  uint flags;
+
+  for(i = PGROUNDUP(start); i < start + sz; i += PGSIZE){
+    if((pte = walk(old, i, 0)) == 0)
+      panic("kvmcopymappings: pte should exist");
+    if((*pte & PTE_V) == 0)
+      panic("kvmcopymappings: page not present");
+    pa = PTE2PA(*pte);
+    // 获取页表项 pte 中的标志位，并将用户权限标志位 PTE_U 清除，以确保将来的映射是非用户页的映射。
+    flags = PTE_FLAGS(*pte) & ~PTE_U;
+    if(mappages(new, i, PGSIZE, pa, flags) != 0){
+      uvmunmap(new, 0, i / PGSIZE, 0);
+      return -1;
+    }
   }
-  if (got_null) {
-    return 0;
-  } else {
-    return -1;
+
+  return 0;
+  
+}
+
+
+// 用于内核页表内程序内存映射与用户页表程序内存映射之间的同步
+// 和uvmdealloc一样的，只是在uvmunmap的时候不释放实际内存
+uint64 kvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+{
+  if(newsz >= oldsz) return oldsz;
+
+  // 取消虚拟地址与物理地址之间的映射关系,从newsz开始的npages个页表
+  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 0);
   }
+
+  return newsz;
 }
 
-// check if use global kpgtbl or not
-int test_pagetable() {
-  uint64 satp = r_satp();
-  uint64 gsatp = MAKE_SATP(kernel_pagetable);
-  printf("test_pagetable: %d\n", satp != gsatp);
-  return satp != gsatp;
-}
\ No newline at end of file
