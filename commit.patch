diff --git a/Makefile b/Makefile
index cac799d..94e7f9f 100644
--- a/Makefile
+++ b/Makefile
@@ -154,6 +154,9 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_find\
 
 
 ifeq ($(LAB),syscall)
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..2e43eea
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,72 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+
+char *fmtname(char *path) {
+  static char buf[DIRSIZ + 1];
+  char *p;
+
+  // Find first character after last slash.
+  for (p = path + strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+
+  if (strlen(p) >= DIRSIZ) return p;
+  memmove(buf, p, strlen(p));
+  buf[strlen(p)] = 0;
+  return buf;
+}
+
+void find(char *path, char *target)
+{
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if((fd = open(path, 0)) < 0){
+    fprintf(2, "ls: cannot open %s\n", path);
+    return;
+  }
+
+  if(fstat(fd, &st) < 0){
+    fprintf(2, "ls: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  switch(st.type){
+    case T_FILE:
+      if(!strcmp(fmtname(path), target))printf("%s\n", path);
+      break;
+
+    case T_DIR: 
+      if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+        printf("ls: path too long\n");
+        break;
+      }
+      strcpy(buf, path);
+      p = buf + strlen(buf);
+      *p++ = '/';
+      while(read(fd, &de, sizeof(de)) == sizeof(de)){
+        if(de.inum == 0 ||  strcmp(de.name, ".")==0 || strcmp(de.name, "..")==0)
+          continue;
+        memmove(p, de.name, strlen(de.name));
+        p[strlen(de.name)] = 0;
+        find(buf, target);
+      }
+      break;
+  }
+  close(fd);
+}
+
+int main(int argc, char *argv[])
+{
+  if(argc < 3){
+    find(".",argv[1]);
+    exit(0);
+  }
+  find(argv[1], argv[2]);
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..dd00935
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,32 @@
+#include "kernel/types.h"
+#include "user.h"
+int main(int argc, char* argv[]){
+    int p1[2]; 
+    int p2[2];
+    pipe(p1);
+    pipe(p2);
+    int ret = fork();
+    if(ret == 0) {
+        /*子进程*/
+        close(p1[1]);  //p[1]为管道写入端，p[0]为管道读出端
+        close(p2[0]);
+        char sonbuff[4];
+        read(p1[0], sonbuff, 4);
+        close(p1[0]);
+        printf("%d: received %s\n", getpid(), sonbuff); 
+        write(p2[1],"pong", 4);
+        close(p2[1]);
+        
+    }else if(ret > 0){
+        /*父进程*/
+        close(p1[0]); //关闭读端
+        close(p2[1]);
+        write(p1[1],"ping", 4);
+        close(p1[1]);
+        char fatherbuff[4];
+        read(p2[0],fatherbuff, 4);     
+        close(p2[0]);
+        printf("%d: received %s\n",getpid(), fatherbuff);
+    }
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..01aec51
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "user.h"
+
+int main(int argc, char* argv[]){
+    if(argc != 2){
+        printf("Sleep needs one argument!\n");
+        exit(-1);
+    }
+    int ticks = atoi(argv[1]);
+    sleep(ticks);
+    printf("(nothing happens for a little while)\n");
+    exit(0);
+}
\ No newline at end of file
